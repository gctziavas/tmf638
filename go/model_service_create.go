/*
 * Service Inventory Management
 *
 * ## TMF API Reference : TMF 638 - Service Inventory Management   Version 4.0   The intent of this API is to provide a consistent/standardized mechanism to query and manipulate the Service inventory.  The Service Inventory API can be used to query the service instances for a customer via Self Service Portal or the Call Centre operator can query the service instances on behalf of the customer while a customer may have a complaint or a query. Note: Only the CustomerFacingServices instances will be presented to the customer.  The Service Inventory API can be called by the Service Order Management to create a new service instance/ update an existing service instance in the Service Inventory.  ### Service resource Service is an abstract base class for defining the Service hierarchy. All Services are characterized as either being possibly visible and usable by a Customer or not. This gives rise to the two subclasses of  Service: CustomerFacingService and ResourceFacingService.  ### Service Inventory API performs the following operations on service  : - Retrieve  a service or a collection of services depending on filter criteria - Partial update of a service (including updating rules) - Create a service (including default values and creation rules and for administration users only) - Delete a service (for administration users only) - Notification of events on service  Copyright (c)TM Forum 2019. All Rights Reserved.
 *
 * API version: 4.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package tmf638

import (
	"log"
	"os/exec"
	"time"
)

// ServiceCreate - Service is a base class for defining the Service hierarchy. All Services are characterized as either being possibly visible and usable by a Customer or not. This gives rise to the two subclasses of Service: CustomerFacingService and ResourceFacingService. Skipped properties: id,href
type ServiceCreate struct {

	// Is it a customer facing or resource facing service
	Category string `json:"category,omitempty"`

	// Free-text description of the service
	Description string `json:"description,omitempty"`

	// Date when the service ends
	EndDate time.Time `json:"endDate,omitempty"`

	// If TRUE, this Service has already been started
	HasStarted bool `json:"hasStarted,omitempty"`

	// If true, the service is a ServiceBundle which regroup a service hierachy. If false, the service is a 'atomic' service (hierachy leaf).
	IsBundle bool `json:"isBundle,omitempty"`

	// If FALSE and hasStarted is FALSE, this particular Service has NOT been enabled for use - if FALSE and hasStarted is TRUE then the service has failed
	IsServiceEnabled bool `json:"isServiceEnabled,omitempty"`

	// If TRUE, this Service can be changed without affecting any other services
	IsStateful bool `json:"isStateful,omitempty"`

	// Name of the service
	Name string `json:"name,omitempty"`

	// Date when the service was created (whatever its status).
	ServiceDate string `json:"serviceDate,omitempty"`

	// Business type of the service
	ServiceType string `json:"serviceType,omitempty"`

	// Date when the service starts
	StartDate time.Time `json:"startDate,omitempty"`

	// This attribute is an enumerated integer that indicates how the Service is started, such as: 0: Unknown; 1: Automatically by the managed environment; 2: Automatically by the owning device; 3: Manually by the Provider of the Service; 4: Manually by a Customer of the Provider; 5: Any of the above
	StartMode string `json:"startMode,omitempty"`

	// A list of feature associated with this service
	Feature []Feature `json:"feature,omitempty"`

	// A list of notes made on this service
	Note []Note `json:"note,omitempty"`

	// A list of places (Place [*]). Used to define a place useful for the service (for example a geographical place whre the service is installed)
	Place []RelatedPlaceRefOrValue `json:"place,omitempty"`

	// A list of related  entity in relationship with this service
	RelatedEntity []RelatedEntityRefOrValue `json:"relatedEntity,omitempty"`

	// A list of related party references (RelatedParty [*]). A related party defines party or party role linked to a specific entity
	RelatedParty []RelatedParty `json:"relatedParty,omitempty"`

	// A list of characteristics that characterize this service (ServiceCharacteristic [*])
	ServiceCharacteristic []Characteristic `json:"serviceCharacteristic,omitempty"`

	// A list of service order items related to this service
	ServiceOrderItem []RelatedServiceOrderItem `json:"serviceOrderItem,omitempty"`

	// A list of service relationships (ServiceRelationship [*]). Describes links with other service(s) in the inventory.
	ServiceRelationship []ServiceRelationship `json:"serviceRelationship,omitempty"`

	ServiceSpecification ServiceSpecificationRef `json:"serviceSpecification"`

	State ServiceStateType `json:"state"`

	// A list of supporting resources (SupportingResource [*]).Note: only Service of type RFS can be associated with Resources
	SupportingResource []ResourceRef `json:"supportingResource,omitempty"`

	// A list of supporting services (SupportingService [*]). A collection of services that support this service (bundling, link CFS to RFS)
	SupportingService []ServiceRefOrValue `json:"supportingService,omitempty"`
}

// AssertServiceCreateRequired checks if the required fields are not zero-ed
func AssertServiceCreateRequired(obj ServiceCreate) error {
	elements := map[string]interface{}{
		"serviceSpecification": obj.ServiceSpecification,
		"state":                obj.State,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	for _, el := range obj.Feature {
		if err := AssertFeatureRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Note {
		if err := AssertNoteRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Place {
		if err := AssertRelatedPlaceRefOrValueRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.RelatedEntity {
		if err := AssertRelatedEntityRefOrValueRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.RelatedParty {
		if err := AssertRelatedPartyRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.ServiceCharacteristic {
		if err := AssertCharacteristicRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.ServiceOrderItem {
		if err := AssertRelatedServiceOrderItemRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.ServiceRelationship {
		if err := AssertServiceRelationshipRequired(el); err != nil {
			return err
		}
	}
	if err := AssertServiceSpecificationRefRequired(obj.ServiceSpecification); err != nil {
		return err
	}
	for _, el := range obj.SupportingResource {
		if err := AssertResourceRefRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.SupportingService {
		if err := AssertServiceRefOrValueRequired(el); err != nil {
			return err
		}
	}
	return nil
}

// AssertRecurseServiceCreateRequired recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of ServiceCreate (e.g. [][]ServiceCreate), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseServiceCreateRequired(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aServiceCreate, ok := obj.(ServiceCreate)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertServiceCreateRequired(aServiceCreate)
	})
}

func ServiceCreateToService(screate ServiceCreate) Service {
	var svc Service
	uuid, err := exec.Command("uuidgen").Output()
	if err != nil {
		log.Fatal(err)
	}
	svc.Id = string(uuid)
	svc.Category = screate.Category
	svc.Description = screate.Description
	svc.Name = screate.Name
	svc.State = screate.State
	svc.ServiceSpecification = screate.ServiceSpecification
	svc.EndDate = screate.EndDate
	svc.StartDate = screate.StartDate
	svc.Feature = screate.Feature
	svc.HasStarted = screate.HasStarted
	svc.IsBundle = screate.IsBundle
	svc.IsServiceEnabled = screate.IsServiceEnabled
	svc.IsStateful = screate.IsStateful
	svc.Note = screate.Note
	svc.Place = screate.Place
	svc.RelatedEntity = screate.RelatedEntity
	svc.RelatedParty = screate.RelatedParty
	svc.ServiceCharacteristic = screate.ServiceCharacteristic
	svc.ServiceDate = screate.ServiceDate
	svc.ServiceOrderItem = screate.ServiceOrderItem
	svc.ServiceRelationship = screate.ServiceRelationship
	svc.ServiceType = screate.ServiceType
	svc.StartMode = screate.StartMode
	svc.SupportingResource = screate.SupportingResource
	svc.SupportingService = screate.SupportingService

	return svc
}
