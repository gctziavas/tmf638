/*
 * Service Inventory Management
 *
 * ## TMF API Reference : TMF 638 - Service Inventory Management   Version 4.0   The intent of this API is to provide a consistent/standardized mechanism to query and manipulate the Service inventory.  The Service Inventory API can be used to query the service instances for a customer via Self Service Portal or the Call Centre operator can query the service instances on behalf of the customer while a customer may have a complaint or a query. Note: Only the CustomerFacingServices instances will be presented to the customer.  The Service Inventory API can be called by the Service Order Management to create a new service instance/ update an existing service instance in the Service Inventory.  ### Service resource Service is an abstract base class for defining the Service hierarchy. All Services are characterized as either being possibly visible and usable by a Customer or not. This gives rise to the two subclasses of  Service: CustomerFacingService and ResourceFacingService.  ### Service Inventory API performs the following operations on service  : - Retrieve  a service or a collection of services depending on filter criteria - Partial update of a service (including updating rules) - Create a service (including default values and creation rules and for administration users only) - Delete a service (for administration users only) - Notification of events on service  Copyright (c)TM Forum 2019. All Rights Reserved.
 *
 * API version: 4.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package tmf638

import (
	"time"
)

// ServiceRefOrValue - A Service to be created defined by value or existing defined by reference. The polymorphic attributes @type, @schemaLocation & @referredType are related to the Service entity and not the RelatedServiceRefOrValue class itself
type ServiceRefOrValue struct {

	// Unique identifier of the service
	Id string `json:"id"`

	// Reference of the service
	Href string `json:"href,omitempty"`

	// Is it a customer facing or resource facing service
	Category string `json:"category,omitempty"`

	// Free-text description of the service
	Description string `json:"description,omitempty"`

	// Date when the service ends
	EndDate time.Time `json:"endDate,omitempty"`

	// If TRUE, this Service has already been started
	HasStarted bool `json:"hasStarted,omitempty"`

	// If true, the service is a ServiceBundle which regroup a service hierachy. If false, the service is a 'atomic' service (hierachy leaf).
	IsBundle bool `json:"isBundle,omitempty"`

	// If FALSE and hasStarted is FALSE, this particular Service has NOT been enabled for use - if FALSE and hasStarted is TRUE then the service has failed 
	IsServiceEnabled bool `json:"isServiceEnabled,omitempty"`

	// If TRUE, this Service can be changed without affecting any other services
	IsStateful bool `json:"isStateful,omitempty"`

	// Name of the service
	Name string `json:"name,omitempty"`

	// Date when the service was created (whatever its status).
	ServiceDate string `json:"serviceDate,omitempty"`

	// Business type of the service
	ServiceType string `json:"serviceType,omitempty"`

	// Date when the service starts
	StartDate time.Time `json:"startDate,omitempty"`

	// This attribute is an enumerated integer that indicates how the Service is started, such as: 0: Unknown; 1: Automatically by the managed environment; 2: Automatically by the owning device; 3: Manually by the Provider of the Service; 4: Manually by a Customer of the Provider; 5: Any of the above
	StartMode string `json:"startMode,omitempty"`

	// A list of feature associated with this service 
	Feature []Feature `json:"feature,omitempty"`

	// A list of notes made on this service
	Note []Note `json:"note,omitempty"`

	// A list of places (Place [*]). Used to define a place useful for the service (for example a geographical place whre the service is installed)
	Place []RelatedPlaceRefOrValue `json:"place,omitempty"`

	// A list of related  entity in relationship with this service 
	RelatedEntity []RelatedEntityRefOrValue `json:"relatedEntity,omitempty"`

	// A list of related party references (RelatedParty [*]). A related party defines party or party role linked to a specific entity
	RelatedParty []RelatedParty `json:"relatedParty,omitempty"`

	// A list of characteristics that characterize this service (ServiceCharacteristic [*]) 
	ServiceCharacteristic []Characteristic `json:"serviceCharacteristic,omitempty"`

	// A list of service order items related to this service
	ServiceOrderItem []RelatedServiceOrderItem `json:"serviceOrderItem,omitempty"`

	// A list of service relationships (ServiceRelationship [*]). Describes links with other service(s) in the inventory.
	ServiceRelationship []ServiceRelationship `json:"serviceRelationship,omitempty"`

	ServiceSpecification ServiceSpecificationRef `json:"serviceSpecification,omitempty"`

	State ServiceStateType `json:"state,omitempty"`

	// A list of supporting resources (SupportingResource [*]).Note: only Service of type RFS can be associated with Resources
	SupportingResource []ResourceRef `json:"supportingResource,omitempty"`

	// A list of supporting services (SupportingService [*]). A collection of services that support this service (bundling, link CFS to RFS)
	SupportingService []ServiceRefOrValue `json:"supportingService,omitempty"`

	// When sub-classing, this defines the super-class
	BaseType string `json:"@baseType,omitempty"`

	// A URI to a JSON-Schema file that defines additional attributes and relationships
	SchemaLocation string `json:"@schemaLocation,omitempty"`

	// When sub-classing, this defines the sub-class Extensible name
	Type string `json:"@type,omitempty"`

	// The actual type of the target instance when needed for disambiguation.
	ReferredType string `json:"@referredType,omitempty"`
}

// AssertServiceRefOrValueRequired checks if the required fields are not zero-ed
func AssertServiceRefOrValueRequired(obj ServiceRefOrValue) error {
	elements := map[string]interface{}{
		"id": obj.Id,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	for _, el := range obj.Feature {
		if err := AssertFeatureRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Note {
		if err := AssertNoteRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Place {
		if err := AssertRelatedPlaceRefOrValueRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.RelatedEntity {
		if err := AssertRelatedEntityRefOrValueRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.RelatedParty {
		if err := AssertRelatedPartyRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.ServiceCharacteristic {
		if err := AssertCharacteristicRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.ServiceOrderItem {
		if err := AssertRelatedServiceOrderItemRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.ServiceRelationship {
		if err := AssertServiceRelationshipRequired(el); err != nil {
			return err
		}
	}
	if err := AssertServiceSpecificationRefRequired(obj.ServiceSpecification); err != nil {
		return err
	}
	for _, el := range obj.SupportingResource {
		if err := AssertResourceRefRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.SupportingService {
		if err := AssertServiceRefOrValueRequired(el); err != nil {
			return err
		}
	}
	return nil
}

// AssertRecurseServiceRefOrValueRequired recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of ServiceRefOrValue (e.g. [][]ServiceRefOrValue), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseServiceRefOrValueRequired(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aServiceRefOrValue, ok := obj.(ServiceRefOrValue)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertServiceRefOrValueRequired(aServiceRefOrValue)
	})
}
